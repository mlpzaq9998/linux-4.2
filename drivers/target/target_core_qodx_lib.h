#ifndef TARGET_CORE_QODX_LIB_H
#define TARGET_CORE_QODX_LIB_H


#include <linux/types.h>
#include <linux/kernel.h>
#include <asm/unaligned.h>
#include <scsi/scsi.h>

#include "target_core_qlib.h"
#include "target_core_qodx_scsi.h"

/**/
#ifdef SUPPORT_FAST_BLOCK_CLONE
#define SUPPORT_FBC(a,b) (((a & b) == b) ? true : false)
#endif


/**/
#define SPC_SENSE_KEY_OFFSET			2
#define SPC_ADD_SENSE_LEN_OFFSET		7
#define SPC_DESC_TYPE_OFFSET			8
#define SPC_ADDITIONAL_DESC_LEN_OFFSET		9
#define SPC_VALIDITY_OFFSET			10
#define SPC_ASC_KEY_OFFSET			12
#define SPC_ASCQ_KEY_OFFSET			13

/* now is 512KB for dm-thin block size ... */
#define ALIGNED_SIZE_BYTES	(1 << 19)

/**/
#define MAX_SG_IO_DATA_COUNT	8
struct sg_io_data {
	struct scatterlist	*data_sg;
	u64			data_len;
	u32			data_sg_nents;
};

struct wut_io_data {
	struct tpc_cmd_data	*tc_p;
	struct tpc_token_data	*s_token;
	struct tpc_token_data	*d_token;
	struct workqueue_struct *odx_wq;
	u64			nr_bytes;        /* nr bytes to work */
	u64			s_rod_off_bytes; /* offset bytes to source rod data */
	sector_t		dest_lba;
	u32			dest_bs_order;
	RC			rc;
	struct sg_io_data	sg_io[MAX_SG_IO_DATA_COUNT];
} __attribute__ ((packed));

/* used by wq */
struct wut_io_work_data {
	struct list_head	node;
	struct wut_io_data 	*io_data;
	struct __cb_data	*cb_data;
	struct work_struct	wut_io_work;
	sector_t		start_lba;
	u64			nr_bytes;
	int			sg_idx;
	bool			is_write;
	bool			transfer_done;
} __attribute__ ((packed));


#define MD5_SIGNATURE_SIZE	16	/* 16 bytes in a MD5 message digest */
#define ODX_INVALID_OP		0x0
#define ODX_CP_OP		0x1
#define ODX_MONITOR_OP		0x2

/* OBJ TOKEN STATUS */
typedef enum{
	O_TOKEN_NOT_ALLOCATED_AND_NOT_ALIVE  = 0, /* intial value */
	O_TOKEN_ALLOCATED_BUT_NOT_ALIVE  ,   /* token was allocated but not record in token_data */
	O_TOKEN_ALIVE                    ,   /* token was allocated and record in token_data */
	O_TOKEN_FREE_BY_PROC             ,   /* token will be free by other procedure */
	O_TOKEN_EXPIRED                  ,   /* token was expired */
	O_TOKEN_CANCELLED                ,   /* token was cancelled by copy manager */
	O_TOKEN_DELETED                  ,   /* token was deleted by ap client */
} TOKEN_STS;

/** 
 * @struct
 * @brief
 * @note
 */
#define CMD_ASKED_NOTHING		0
#define CMD_ASKED_BY_ABORT_TASK		1
#define CMD_ASKED_BY_ABORT_TASK_SET	2	/* TBD: we don't support this */
#define CMD_ASKED_BY_CLEAR_ACA		3	/* TBD: we don't support this */
#define CMD_ASKED_BY_CLEAR_TASK_SET	4	/* TBD: we don't support this */
#define CMD_ASKED_BY_LUN_RESET		5
#define CMD_ASKED_BY_TARGET_WARM_RESET	6	/* TBD: we don't support this */
#define CMD_ASKED_BY_TARGET_COLD_RESET	7	/* TBD: we don't support this */
#define CMD_ASKED_BY_RELEASE_CONN	8

/* The CUR_STATUS doesn't relate to copy operation status */
typedef enum{
	T_CMD_NOT_START         = 0 ,
	T_CMD_IS_STARTING_IN_FG ,
	T_CMD_IS_STARTING_IN_BG ,
	T_CMD_COMPLETED_W_ERR   ,
	T_CMD_COMPLETED_WO_ERR  ,
	T_CMD_WAS_ABORTED       ,
	MAX_T_CMD_STATUS        ,
}T_CMD_STATUS;

/* The OBJ_DATA_TYPE will indicate what kind of data will be kept by tpc obj */
typedef enum{
    O_DATA_TYPE_NONE        = 0,  /* no any data generated by 3rd-party copy command */
    O_DATA_TYPE_ROD            ,  /* the rod (include rod token) generated by 3rd-party copy command */
    O_DATA_TYPE_HOLD_DATA      ,  /* the hold data generated by 3rd-party copy command */
}OBJ_DATA_TYPE;



/** 
 * @struct BLK_RANGE_OBJ
 * @brief
 * @note 
 *
 */
#define R_STATUS_NOT_USED           0
#define R_STATUS_TRANSFER_USED      1
#define R_STATUS_TRUNCATE_USED      2

struct blk_range_data {
	struct list_head    br_node;
	sector_t            lba;
	u32                 nr_blks;

	/* Please refer the R_STATUS_XXX */
	u32                 curr_status;
	u32                 next_status;
};


/* macro for T_CMD_STATUS */
#define T_CMD_IS_NOT_START(status)          ((status == T_CMD_NOT_START) ? 1 : 0)
#define T_CMD_IS_START_FG(status)           ((status == T_CMD_IS_STARTING_IN_FG) ? 1 : 0)
#define T_CMD_IS_START_BG(status)           ((status == T_CMD_IS_STARTING_IN_BG) ? 1 : 0)
#define T_CMD_WAS_COMPLETED_W_ERR(status)   ((status == T_CMD_COMPLETED_W_ERR) ? 1 : 0)
#define T_CMD_WAS_COMPLETED_WO_ERR(status)  ((status == T_CMD_COMPLETED_WO_ERR) ? 1 : 0)
#define T_CMD_WAS_ABORT(status)             ((status == T_CMD_WAS_ABORTED) ? 1 : 0)

/*****************************************
 * macro for TPC TOKEN STATUS 
 ******************************************/
#define TOKEN_NOT_ALLOCATED_AND_NOT_ALIVE(t_status) \
	((t_status == O_TOKEN_NOT_ALLOCATED_AND_NOT_ALIVE) ? 1 : 0)

#define TOKEN_ALLOCATED_NOT_ALIVE(t_status) \
	((t_status == O_TOKEN_ALLOCATED_BUT_NOT_ALIVE) ? 1 : 0)

#define TOKEN_ALIVE(t_status)		((t_status == O_TOKEN_ALIVE) ? 1 : 0)

#define TOKEN_FREE_BY_PROC(t_status)	((t_status == O_TOKEN_FREE_BY_PROC) ? 1 : 0)
#define TOKEN_EXPIRED(t_status)		((t_status == O_TOKEN_EXPIRED) ? 1 : 0)
#define TOKEN_CANCELLED(t_status)	((t_status == O_TOKEN_CANCELLED) ? 1 : 0)
#define TOKEN_DELETED(t_status)		((t_status == O_TOKEN_DELETED) ? 1 : 0)


#define IS_TPC_SCSI_OP(cdb_byte0) \
	((cdb_byte0 == EXTENDED_COPY) || (cdb_byte0 == RECEIVE_COPY_RESULTS))

#define IS_TPC_SCSI_PT_OP(cdb_byte1) (((cdb_byte1 & 0x1f) == 0x10))
#define IS_TPC_SCSI_WUT_OP(cdb_byte1) (((cdb_byte1 & 0x1f) == 0x11))
#define IS_TPC_SCSI_RRTI_OP(cdb_byte1) (((cdb_byte1 & 0x1f) == 0x07))

#define SAME_ID_OP_SAC(s_id, d_id, s_opsac, d_opsac) ((s_id == d_id) && (s_opsac == d_opsac))
#define GET_OP_SAC(cdb_byte0, cdb_byte1) ((cdb_byte0 << 8) | (cdb_byte1 & 0x1f))


/**/
struct __reg_data {
	/* where token comes from */
	u64			initiator_id_hi;
	u64			initiator_id_lo;
	/* where token goes to */
	u64			tpg_id_hi;
	u64			tpg_id_lo;
	/**/
	u64			cmd_id_hi;
	u64			cmd_id_lo;
	struct __dev_info	dev_info;
	u32			list_id;
	u32			sac;
	int			cmd_type;
} __attribute__ ((packed));

struct tpc_tpg_data {
	struct rb_node		node;
	struct rb_root		cmd_root; /* curr working command */
	struct rb_root		token_root;
	spinlock_t		token_root_lock;
	spinlock_t		cmd_root_lock;
	atomic_t		ref_count;
	u64			id_hi;
	u64			id_lo;
	struct work_struct 	del_work;
};

struct tpc_cmd_data {
	struct rb_node		node;
	struct tpc_tpg_data	*tpg_p;
	struct list_head	del_node;
	struct __reg_data	reg_data;
	spinlock_t		cmd_asked_act_lock;
	spinlock_t		status_lock;
	spinlock_t		transfer_count_lock;
	atomic_t		ref_count;
	atomic_t		cmd_asked;
	atomic_t		cmd_status;

	/* FIXED ME !!
	 * the unit of transfer_count field is block-based for
	 * RECEIVE ROD TOKEN INFORMATION command of SBC specification currently.
	 * (SBC3R31, page 156)
	 */
	u64			transfer_count;
	u16			segs_processed;
	u16			op_counter;
	u8			sense_data[ROD_SENSE_DATA_LEN];
};

struct tpc_token_data {
	struct rb_node		node;
	struct tpc_tpg_data	*tpg_p;
#ifdef SUPPORT_TPC_CMD
	/* used for fast block cloning */
	void			*se_dev;
#endif
	struct list_head	del_node;
	struct __reg_data	reg_data;
	struct timer_list	timer;
	struct list_head	br_list;
	spinlock_t		br_list_lock;
	spinlock_t		transfer_count_lock;
	atomic_t		status;
	atomic_t		ref_count;
	void			*token;
	unsigned long		create_time;
	u32			token_timeout;
	bool			next_delete;
	/* --------------------------------------------------------
	 * --- Basic information for copy-operation data record ---
	 * --------------------------------------------------------
	 */

	/* The unit of transfer_count field is block-based for
	 * RECEIVE ROD TOKEN INFORMATION command of SBC specification currently.
	 * (SBC3R31, page 156)
	 */
	u64			transfer_count;
	u16			segs_processed;
	u16			op_counter;
	u16			cp_op_status;

	/* Status about the tpc cmd that originated copy operation. This will be 
	 * set to scsi status code. Please refer the SAM_STAT_XXXX in
	 * include\scsi\scsi.h
	*/
	u16			completion_status;
	u8			sense_data[ROD_SENSE_DATA_LEN];
};

#define MAX_ODX_WR_DATA_LEN	(1 << 20)
struct odx_work_request {
	u8 			*cdb;
	void 			*buff;
#ifdef SUPPORT_TPC_CMD
	/* used for fast block cloning */
	void			*se_dev;
#endif
	struct tpc_tpg_data	*tpg_p;
	struct tpc_cmd_data	*tc_p;
	struct workqueue_struct *odx_wq;
	/* registered data we want to touch */
	struct __reg_data	reg_data;
	struct sg_io_data	sg_io[MAX_SG_IO_DATA_COUNT];

	/* used to report final transfer count to struct se_cmd */
	u64			transfer_counts;	/* sector-based */
	RC			rc;
} __attribute__ ((packed));



/** 
 * @struct
 * @brief
 */
struct build_tpc_desc{
	TPC_DESC_TYPE_CODE desc_code;
	int (*get_desc_len)(u16 *);
	int (*build_desc)(struct __dev_info *, TPC_DESC_TYPE_CODE, u8 *);
} __attribute__ ((packed));


/** 
 * @struct
 * @brief
 */
struct rod_type_table {
	u32     rod_type;
	bool    end_table;

	/*
	 * TokenOut - 1 : Indicate the copy manager supports the generation and
	 *                returning of ROD tokens that have ROD type indicated by 
	 *                ROD_TYPE filed by one or more commands that the copy 
	 *                manager processes
	 *
	 * TokenOut - 0 : Indicate the copy manager does NOT supports the generation
	 *                and returning of ROD tokens that have ROD type indicated by 
	 *                ROD_TYPE filed
	 */

	u32     token_out;

	/*
	 * TokenIn - 1 : Indicate the copy manager supports the receipt of ROD tokens
	 *               that have ROD type indicated by ROD_TYPE filed by one or more
	 *               commands that the copy manager processes
	 *
	 * TokenIn - 0 : Indicate the copy manager does NOT supports the receipt of
	 *               ROD tokens that have ROD type indicated by ROD_TYPE filed
	 */

	u32     token_in;
	/*
	 * EcpyInt - 1 : Support the ROD type indicated by ROD_TYPE filed for internal
	 *               RODs in the EXTENDED COPY command
	 *
	 * EcpyInt - 0 : Does NOT Support the ROD type indicated by ROD_TYPE filed 
	 *               for internal RODs in the EXTENDED COPY command
	 */

	u32     ecpy_int_bit;
	u32     preference_indication;
};

static inline T_CMD_STATUS __odx_get_tc_data_status(
	struct tpc_cmd_data *tc_data
	)
{
	return (T_CMD_STATUS)atomic_read(&tc_data->cmd_status);
}

static inline void __odx_update_tc_data_status(
	struct tpc_cmd_data *tc_data,
	T_CMD_STATUS status
	)
{
	atomic_set(&tc_data->cmd_status, status);
}

static inline void __odx_update_token_status(
	struct tpc_token_data *token, 	
	TOKEN_STS status
	)
{
	atomic_set(&token->status, status);
}

static inline int __odx_cmpxchg_token_status(
	struct tpc_token_data *token, 	
	TOKEN_STS old_status,
	TOKEN_STS new_status
	)
{
	return atomic_cmpxchg(&token->status, old_status, new_status);
}

static inline void __odx_lock_update_tc_cmd_transfer_count(
	struct tpc_cmd_data *tc_cmd,
	sector_t nr_blks
	)
{
	spin_lock(&tc_cmd->transfer_count_lock);
	tc_cmd->transfer_count += nr_blks;
	spin_unlock(&tc_cmd->transfer_count_lock);
}

static inline sector_t __odx_lock_get_tc_cmd_transfer_count(
	struct tpc_cmd_data *tc_cmd
	)
{
	sector_t nr_blks = 0;

	spin_lock(&tc_cmd->transfer_count_lock);
	nr_blks = tc_cmd->transfer_count;
	spin_unlock(&tc_cmd->transfer_count_lock);
	return nr_blks;
}

/* one cp src and one cp target per one copy command */
#define	MAX_CSCD_DESC_COUNT	2
/* one action per one copy command */
#define	MAX_SEG_DESC_COUNT	1

static inline u16 __tpc_get_max_supported_cscd_desc_count(void)
{
	return MAX_CSCD_DESC_COUNT;
}

static inline u16 __tpc_get_max_supported_seg_desc_count(void)
{
	return MAX_SEG_DESC_COUNT;
}

/* spc4r36, p72 
 * not include additional sense bytes 
 */
#define MIN_FIXED_FORMAT_SENSE_LEN	18	

static inline u32 __odx_get_min_rrti_param_len(void)
{
	/* SPC4R36 , page 430 
	 * the min len will be 0x238
	 */
	return (sizeof(struct rod_token_info_param) + \
		MIN_FIXED_FORMAT_SENSE_LEN + 4 + (ROD_TOKEN_MIN_SIZE + 2));
}

static inline u32 __tpc_get_total_supported_desc_len(void)
{
    return (
    	__tpc_get_max_supported_cscd_desc_count() * sizeof(GEN_CSCD_DESC) + \
    	__tpc_get_max_supported_seg_desc_count() * sizeof(GEN_SEG_DESC)
    	);
}

static inline u16 __odx_get_max_supported_blk_dev_range(void)
{
	/* FIXED ME !!
	 *
	 * Here, The value of max supported blk device range can not be larger
	 * than 0x400. The reason is the some testing items in Offload SCSI
	 * Compliance Test (LOGO) in WINDOWS HCK (ver: 8.59.29757) will be fail.
	 * Actually, we can not find any information (or document) about the
	 * limitation of this.
	 * Therefore, we limit it to 512 / 64MB = 8
	 */
	 return (MAX_TRANSFER_SIZE_IN_BYTES / OPTIMAL_TRANSFER_SIZE_IN_BYTES);
}

static inline u16 __odx_get_desc_counts(
	u16 len
	)
{
	/* The block dev range desc length shall be a multiple of 16 */
	return ((len & (~0x000f)) / sizeof(struct blk_dev_range_desc));
}

static inline sector_t __odx_get_total_nr_blks_by_desc(
	struct blk_dev_range_desc *s,
	u16 desc_counts
	)
{
	u16 index = 0;
	sector_t nr_blks = 0;

	for(index = 0; index < desc_counts; index++)
		nr_blks += (sector_t)get_unaligned_be32(&s[index].nr_blks[0]);

	return nr_blks;
}

static inline bool __odx_is_odx_opcode(
	u8 *cdb_byte
	)
{
	if (IS_TPC_SCSI_OP(cdb_byte[0])
	&& (IS_TPC_SCSI_PT_OP(cdb_byte[1]) 
		|| IS_TPC_SCSI_WUT_OP(cdb_byte[1])
		|| IS_TPC_SCSI_RRTI_OP(cdb_byte[1]))
	)
		return true;

	return false;
}

static inline int __odx_get_list_id_by_cdb(
	u8 *cdb_byte,
	u32 *list_id
	)
{
	if ((cdb_byte[0] == EXTENDED_COPY) 
	&& (IS_TPC_SCSI_PT_OP(cdb_byte[1]) || IS_TPC_SCSI_WUT_OP(cdb_byte[1]))
	)
	{
		*list_id = get_unaligned_be32(&cdb_byte[6]);
		return 0;
	}

	if ((cdb_byte[0] == RECEIVE_COPY_RESULTS) 
	&& (IS_TPC_SCSI_RRTI_OP(cdb_byte[1]))
	)
	{
		*list_id = get_unaligned_be32(&cdb_byte[2]);
		return 0;
	}

	return -EINVAL;
}


static inline int __odx_is_token_deleted(
	TOKEN_STS token_status
	)
{
	if (TOKEN_DELETED(token_status)
	|| TOKEN_FREE_BY_PROC(token_status)
	)
		return 0;
	return -EINVAL;
}

static inline int __odx_is_token_invalid(
	struct tpc_token_data *token,
	RC *rc
	)
{
	int ret = -ENODEV, status;
	*rc = RC_GOOD;

	status = atomic_read(&token->status);

	if (TOKEN_CANCELLED(status))
		*rc = RC_INVALID_TOKEN_OP_AND_TOKEN_CANCELLED;
	else if (TOKEN_EXPIRED(status))
		*rc = RC_INVALID_TOKEN_OP_AND_TOKEN_EXPIRED;
	else if (__odx_is_token_deleted(status) == 0)
		*rc = RC_INVALID_TOKEN_OP_AND_TOKEN_DELETED;
	else
		ret = 0;
	return ret;
}

static inline bool __odx_cmd_was_asked_drop(
	struct tpc_cmd_data *tc_cmd
	)
{
	bool drop = false;

	switch(atomic_read(&tc_cmd->cmd_asked)) {
	case CMD_ASKED_BY_ABORT_TASK:
	case CMD_ASKED_BY_ABORT_TASK_SET:
	case CMD_ASKED_BY_CLEAR_ACA:
	case CMD_ASKED_BY_CLEAR_TASK_SET:
	case CMD_ASKED_BY_LUN_RESET:
	case CMD_ASKED_BY_TARGET_WARM_RESET:
	case CMD_ASKED_BY_TARGET_COLD_RESET:
	case CMD_ASKED_BY_RELEASE_CONN:
		drop = true;
		break;
	default:
		break;
	}

	return drop;
}

/* other odx helper functions */
int __odx_check_valid_supported_rod_type(u32 rod_type);

int __odx_check_max_lba_in_desc_list(
	struct blk_dev_range_desc *s, 
	sector_t max_lba, 
	u16 counts
	);

int __odx_check_overlap_lba_in_desc_list(
	struct blk_dev_range_desc *s,
	u16 counts
	);

int __odx_check_same_lba_in_desc_list(
	struct blk_dev_range_desc *s,
	u16 counts
	);

int __odx_is_duplicated_token_then_delete(
	struct tpc_tpg_data * tpg_p, 
	u64 cmd_id_hi, 
	u64 cmd_id_lo, 
	u64 initiator_id_hi, 
	u64 initiator_id_lo
	);

struct tpc_token_data *__odx_token_data_alloc(
	struct odx_work_request *odx_wr,
	struct __reg_data *data
	);

void __odx_token_data_free(struct tpc_token_data *p);

void __odx_build_512b_token_data(
	struct odx_work_request *odx_wr,
	struct tpc_token_data *token
	);

void __odx_set_obj_op_counter(struct tpc_token_data *token);
int __odx_set_obj_completion_status(struct tpc_token_data *token);
void __odx_setup_token_timer(struct tpc_token_data *token, u32 timeout);
struct blk_range_data *__odx_alloc_br(void);
void __odx_free_br_lists(struct list_head *data_list);
void __odx_free_token_lists(struct list_head *data_list);

int __odx_wut_get_src_tpg_p_and_token_p(
	struct rod_token_512b *s_token512b_p, 
	struct tpc_tpg_data **s_tpg_p, 
	struct tpc_token_data **s_token_p, 
	struct tpc_token_data *d_token_p, 
	RC * rc
	);

int __odx_wut_check_rod_off_before_wut_io(
	struct tpc_token_data *s_token_p,
	struct tpc_token_data *d_token_p, 
	sector_t src_nr_blks,
	sector_t dest_nr_blks,
	u64 off_to_rod,
	RC *rc
	);

void __odx_build_token_sense_data(
	struct tpc_token_data *token,
	RC rc,
	u8 asc,
	u8 ascq
	);

sector_t __odx_lock_get_nr_blks_by_s_token(struct tpc_token_data *s_token_p);

struct blk_range_data * __odx_get_br_loc_by_rod_off(
	struct tpc_token_data *s_token,
	u64 off_bytes_to_rod, 
	sector_t *br_off
	);

int odx_alloc_cache_res(void);
void odx_free_cache_res(void);
struct workqueue_struct *odx_alloc_wut_io_wq(char *name, int idx);
void odx_destroy_wut_io_wq(struct workqueue_struct *wq);

int __odx_wut_io(
	struct odx_work_request *odx_wr,
	struct tpc_token_data *s_token_p,
	struct tpc_token_data *d_token_p,
	bool run_wuzrt
	);

void odx_alloc_sg_lists(struct odx_work_request *req, bool use_wq);
void odx_free_sg_lists(struct odx_work_request *req);

#ifdef SUPPORT_FAST_BLOCK_CLONE
extern int qnap_do_fast_block_clone_odx(struct wut_io_data *io_data);
#endif

/* odx core functions */
int odx_emulate_evpd_8f(struct odx_work_request *odx_wr);
int odx_core_before_pt(struct odx_work_request *odx_wr, bool *go_pt);
int odx_core_pt(struct odx_work_request *odx_wr);
int odx_core_rrti(struct odx_work_request *odx_wr);
int odx_core_before_wut(struct odx_work_request *odx_wr, bool *go_wut);
int odx_core_wut(struct odx_work_request *odx_wr);

/* odx functions about rb-tree */
struct tpc_token_data *odx_rb_token_get(
	struct tpc_tpg_data *tpg_p,
	u64 cmd_id_hi, 
	u64 cmd_id_lo, 
	u64 initiator_id_hi, 
	u64 initiator_id_lo,
	bool monitor_cp_req
	);

int odx_rb_token_put(struct tpc_token_data *token_p);
int odx_rb_token_add(struct tpc_tpg_data *tpg_p, struct tpc_token_data *token_p);

struct tpc_tpg_data *odx_rb_tpg_get(u64 tpg_id_hi, u64 tpg_id_lo);
int odx_rb_tpg_put(struct tpc_tpg_data *tpg_p);
void odx_rb_tpg_del(struct tpc_tpg_data *tpg_p);

struct tpc_tpg_data *odx_rb_tpg_add_and_get(
	u64 tpg_id_hi,
	u64 tpg_id_lo
	);

int odx_rb_cmd_put(struct tpc_cmd_data *tc_p);

struct tpc_cmd_data *odx_rb_cmd_get(
	struct tpc_tpg_data *tpg_p, 
	struct __reg_data *reg_data,
	bool skip_iid, 
	bool skip_sac
	);

struct tpc_cmd_data *odx_cmd_add_and_get(
	struct tpc_tpg_data *tpg_p, 
	struct __reg_data *reg_data
	);

void odx_rb_cmd_del(struct tpc_tpg_data *tpg_p, struct tpc_cmd_data *tc_p);

struct tpc_cmd_data *odx_rb_cmd_add_and_get(
	struct tpc_tpg_data *tpg_p, 
	struct __reg_data *reg_data
	);

void odx_rb_cmd_free(struct tpc_cmd_data *tc_p);

int odx_rb_parse_conflict_token_range(struct tpc_tpg_data *tpg_p,
	struct __dev_info *dev_info, struct blk_dev_range_desc *blk_range_desc, 
	u16 desc_idx, u8 cdb0, u8 cdb1);

#endif

